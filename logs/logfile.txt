
Starting program: /home/marcio/work/SConvTransform/build/bin/transform-opt -transform=sconv.mlir payload.mlir -debug
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Args: /home/marcio/work/SConvTransform/build/bin/transform-opt -transform=sconv.mlir payload.mlir -debug
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DistinctAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConvertToLLVMPatternInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithRoundingModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SelectLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferDeallocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ValueBoundsOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferViewFlowOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::mesh::ShardingInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
Load new dialect in Context linalg
Load new dialect in Context affine
Load new dialect in Context ub
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ub::PoisonAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaStartOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineMapAccessInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaWaitOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineReadOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineWriteOpInterface)
Load new dialect in Context math
Load new dialect in Context memref
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableMemOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAccessorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedDimOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::AllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RuntimeVerifiableOpInterface)
Load new dialect in Context tensor
Load new dialect in Context complex
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestinationStyleOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::FindPayloadReplacementOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetInsertionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetExtractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TilingInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::AggregatedOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::LinalgOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ContractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ConvolutionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::FillOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PartialReductionOpInterface)
Load new dialect in Context scf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ParallelCombiningOpInterface)
Ignoring repeated interface registration
Ignoring repeated interface registration
Ignoring repeated interface registration
Load new dialect in Context index
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::linalg::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveMemoryEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestinationStyleOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::LinalgOp::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ConvolutionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::MulFOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::AddFOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
Load new dialect in Context transform
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::PatternDescriptorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::ConversionPatternDescriptorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TypeConverterBuilderOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::MatchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformParamTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformHandleTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformValueHandleTypeInterface)
Load new dialect in Context bufferization
Load new dialect in Context llvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::DIRecursiveTypeAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMVoidType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMPPCFP128Type)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMLabelType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMMetadataType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::LLVMStructType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::IntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::AccessGroupOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::AliasAnalysisOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FastmathFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::BranchWeightOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SafeMemorySlotAccessOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::FPExceptionBehaviorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVM::RoundingModeOpInterface)
Load new dialect in Context gpu
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::MMAMatrixType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseDnTensorHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseSpMatHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::SparseSpGEMMOpHandleType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::AsyncOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DeviceMappingAttrInterface)
Load new dialect in Context vector
ImplicitTypeIDRegistry::lookupOrInsert(mlir::vector::MaskableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::vector::MaskingOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorTransferOpInterface)
Load new dialect in Context nvgpu
Load new dialect in Context nvvm
ImplicitTypeIDRegistry::lookupOrInsert(mlir::NVVM::BasicPtxBuilderInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::gpu::TargetAttrInterface)
Load new dialect in Context sparse_tensor
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VerifiableTensorEncoding)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::sparse_tensor::StageWithSortSparseOp)
Load new dialect in Context irdl
ImplicitTypeIDRegistry::lookupOrInsert(mlir::irdl::VerifyConstraintInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::irdl::VerifyRegionInterface)
Load new dialect in Context pdl
Load new dialect in Context pdl_interp
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::transform::TransformHandleTypeInterface>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::NavigationTransformOpTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::detail::MatchOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNResults<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::ReportTrackingListenerFailuresOpTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Read)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::TransformMappingResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Allocate)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Write)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::PayloadIRResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Free)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::PossibleTopLevelTransformOpTrait<Empty>)
[transform-dialect] applying: transform.named_sequence @__transform_main(%arg0: !transform.any_op) {...}
[transform-dialect] Top-level payload before application:
func.func @conv_2d_nchw_fchw(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32> {
  %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
  return %0 : tensor<1x256x64x64xf32>
}
[transform-dialect] ExpensiveChecksEnabled
[transform-dialect] --Start checkAndRecordHandleInvalidation
[transform-dialect] --End checkAndRecordHandleInvalidation -> SUCCESS
[transform-dialect] applying: %0 = transform.structured.match ops{["linalg.conv_2d_nchw_fchw"]} in %arg0 : (!transform.any_op) -> !transform.op<"linalg.conv_2d_nchw_fchw">
[transform-dialect] Top-level payload before application:
func.func @conv_2d_nchw_fchw(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32> {
  %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
  return %0 : tensor<1x256x64x64xf32>
}
[transform-dialect] ExpensiveChecksEnabled
[transform-dialect] --Start checkAndRecordHandleInvalidation
[transform-dialect] ----iterate on handle: <block argument> of type '!transform.any_op' at index: 0
[transform-dialect] ----no consume effect -> SKIP
[transform-dialect] --End checkAndRecordHandleInvalidation -> SUCCESS
[transform-dialect] iterate on handle: <block argument> of type '!transform.any_op' at index: 0
[transform-dialect] --handle not consumed -> SKIP
[transform-dialect] Top-level payload:
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AttributeTrait::IsLocation<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr::Trait<Empty>)
func.func @conv_2d_nchw_fchw(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32> {
  %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
  return %0 : tensor<1x256x64x64xf32>
}
[transform-dialect] applying: %transformed, %loops:4 = transform.structured.sconv %0 : (!transform.op<"linalg.conv_2d_nchw_fchw">) -> (!transform.op<"linalg.generic">, !transform.any_op, !transform.any_op, !transform.any_op, !transform.any_op)
[transform-dialect] Top-level payload before application:
func.func @conv_2d_nchw_fchw(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32> {
  %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
  return %0 : tensor<1x256x64x64xf32>
}
[transform-dialect] ExpensiveChecksEnabled
[transform-dialect] --Start checkAndRecordHandleInvalidation
[transform-dialect] ----iterate on handle: %0 = transform.structured.match ops{["linalg.conv_2d_nchw_fchw"]} in %arg0 : (!transform.any_op) -> !transform.op<"linalg.conv_2d_nchw_fchw">
[transform-dialect] ----found consume effect
[transform-dialect] ----recordOpHandleInvalidation
[transform-dialect] --recordOpHandleInvalidationOne
[transform-dialect] --ancestors: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
[transform-dialect] ----handle one ancestor: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
[transform-dialect] ----of payload with name: "linalg.conv_2d_nchw_fchw"
[transform-dialect] ----of payload: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
[transform-dialect] --recordOpHandleInvalidationOne
[transform-dialect] --ancestors: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
[transform-dialect] ----handle one ancestor: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
[transform-dialect] ----of payload with name: "func.func"
[transform-dialect] ----of payload: func.func @conv_2d_nchw_fchw(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32> {
  %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>
  return %0 : tensor<1x256x64x64xf32>
}
[transform-dialect] --End checkAndRecordHandleInvalidation -> SUCCESS
[transform-dialect] iterate on handle: %0 = transform.structured.match ops{["linalg.conv_2d_nchw_fchw"]} in %arg0 : (!transform.any_op) -> !transform.op<"linalg.conv_2d_nchw_fchw">
[transform-dialect] --handle is consumed
[transform-dialect] --checkRepeatedConsumptionInOperand for Operation*

[sconv-transform]: ConvOp: %0 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64>} ins(%arg0, %arg1 : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(%arg2 : tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>

[sconv-transform]: Collapsed shape: %collapsed = tensor.collapse_shape <<UNKNOWN SSA VALUE>> [[0], [1], [2, 3]] : tensor<1x256x64x64xf32> into tensor<1x256x4096xf32>

ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::detail::GenericOpGenericAdaptorBase::Properties)

[sconv-transform]: GenericOp: %0 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d3, d2 floordiv 64 + d4, d2 mod 64 + d5)>, affine_map<(d0, d1, d2, d3, d4, d5) -> (d1, d3, d4, d5)>, affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2)>], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction"]} ins(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>> : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(<<UNKNOWN SSA VALUE>> : tensor<1x256x4096xf32>) {
^bb0(%in: f32, %in_0: f32, %out: f32):
  %0 = arith.mulf %in, %in_0 : f32
  %1 = arith.addf %0, %out : f32
  linalg.yield %1 : f32
} -> tensor<1x256x4096xf32>
ImplicitTypeIDRegistry::lookupOrInsert(mlir::tensor::detail::ExpandShapeOpGenericAdaptorBase::Properties)

[sconv-transform]: Expanded Shape: ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
%expanded = tensor.expand_shape <<UNKNOWN SSA VALUE>> [[0], [1], [2, 3]] output_shape [1, 256, 64, 64] : tensor<1x256x4096xf32> into tensor<1x256x64x64xf32>

[sconv-transform]: Target before tiling: %0 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d3, d2 floordiv 64 + d4, d2 mod 64 + d5)>, affine_map<(d0, d1, d2, d3, d4, d5) -> (d1, d3, d4, d5)>, affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2)>], iterator_types = ["parallel", "parallel", "parallel", "parallel", "reduction", "reduction"]} ins(<<UNKNOWN SSA VALUE>>, <<UNKNOWN SSA VALUE>> : tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>) outs(<<UNKNOWN SSA VALUE>> : tensor<1x256x4096xf32>) {
^bb0(%in: f32, %in_0: f32, %out: f32):
  %0 = arith.mulf %in, %in_0 : f32
  %1 = arith.addf %0, %out : f32
  linalg.yield %1 : f32
} -> tensor<1x256x4096xf32>
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
makeTiledShapes: for loop#0
computeTileOffsets: <block argument> of type 'index' at index: 0
makeTiledShapes: for loop#1
computeTileOffsets: <block argument> of type 'index' at index: 0
makeTiledShapes: for loop#2
computeTileOffsets: <block argument> of type 'index' at index: 0
makeTiledShapes: for loop#3
computeTileOffsets: <block argument> of type 'index' at index: 0
makeTiledShapes: for loop#4
computeTileOffsets: 0 : index
makeTiledShapes: for loop#5
computeTileOffsets: 0 : index
computeTileSizes: 0 : index
computeTileSizes: 255 : index
computeTileSizes: block with no terminator, has %9 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%9 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
computeTileSizes: block with no terminator, has %10 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%10 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
computeTileSizes: 2 : index
computeTileSizes: 2 : index
makeTiledShapes: for operand <block argument> of type 'tensor<1x128x66x66xf32>' at index: 0: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d0)
computeSliceParameters: raw size: 1 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 1 : index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d3)
computeSliceParameters: raw size: block with no terminator, has %11 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%5 = "affine.min"(%arg2) <{map = affine_map<(d0) -> (-d0 + 128, 33)>}> : (index) -> index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: block with no terminator, has %11 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%5 = "affine.min"(%arg2) <{map = affine_map<(d0) -> (-d0 + 128, 33)>}> : (index) -> index
computeSliceParameters: for dim#2: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d2 floordiv 64 + d4)
computeSliceParameters: raw size: block with no terminator, has %14 = "affine.apply"(%7) <{map = affine_map<(d0) -> ((d0 - 1) floordiv 64 + 3)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%14 = "affine.apply"(%7) <{map = affine_map<(d0) -> ((d0 - 1) floordiv 64 + 3)>}> : (index) -> index
computeSliceParameters: new offset: block with no terminator, has %14 = "affine.apply"(%7) <{map = affine_map<(d0) -> ((d0 - 1) floordiv 64 + 3)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%12 = "affine.apply"(%arg4) <{map = affine_map<(d0) -> (d0 floordiv 64)>}> : (index) -> index
makeTiledShape: new size: block with no terminator, has %14 = "affine.apply"(%7) <{map = affine_map<(d0) -> ((d0 - 1) floordiv 64 + 3)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%14 = "affine.apply"(%7) <{map = affine_map<(d0) -> ((d0 - 1) floordiv 64 + 3)>}> : (index) -> index
computeSliceParameters: for dim#3: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d2 mod 64 + d5)
computeSliceParameters: raw size: block with no terminator, has %17 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - ((d0 - 1) floordiv 64) * 64 + 2)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%17 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - ((d0 - 1) floordiv 64) * 64 + 2)>}> : (index) -> index
computeSliceParameters: new offset: block with no terminator, has %17 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - ((d0 - 1) floordiv 64) * 64 + 2)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%15 = "affine.apply"(%arg4) <{map = affine_map<(d0) -> (d0 mod 64)>}> : (index) -> index
makeTiledShape: new size: block with no terminator, has %17 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - ((d0 - 1) floordiv 64) * 64 + 2)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%17 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - ((d0 - 1) floordiv 64) * 64 + 2)>}> : (index) -> index
makeTiledShapes: for operand <block argument> of type 'tensor<256x128x3x3xf32>' at index: 1: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d1)
computeSliceParameters: raw size: 256 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 256 : index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d3)
computeSliceParameters: raw size: block with no terminator, has %18 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%5 = "affine.min"(%arg2) <{map = affine_map<(d0) -> (-d0 + 128, 33)>}> : (index) -> index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: block with no terminator, has %18 = "affine.apply"(%5) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%5 = "affine.min"(%arg2) <{map = affine_map<(d0) -> (-d0 + 128, 33)>}> : (index) -> index
computeSliceParameters: for dim#2: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d4)
computeSliceParameters: raw size: 3 : index
computeSliceParameters: new offset: 0 : index
makeTiledShape: new size: 3 : index
computeSliceParameters: for dim#3: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d5)
computeSliceParameters: raw size: 3 : index
computeSliceParameters: new offset: 0 : index
makeTiledShape: new size: 3 : index
makeTiledShapes: for operand <block argument> of type 'tensor<1x256x4096xf32>' at index: 1: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d0)
computeSliceParameters: raw size: 1 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 1 : index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d1)
computeSliceParameters: raw size: 256 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 256 : index
computeSliceParameters: for dim#2: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d2)
computeSliceParameters: raw size: block with no terminator, has %19 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%7 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 4096, 1568)>}> : (index) -> index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: block with no terminator, has %19 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%7 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 4096, 1568)>}> : (index) -> index
ImplicitTypeIDRegistry::lookupOrInsert(mlir::tensor::detail::ExtractSliceOpGenericAdaptorBase::Properties)
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d0)
computeSliceParameters: raw size: 1 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 1 : index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d1)
computeSliceParameters: raw size: 256 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: 256 : index
computeSliceParameters: for dim#2: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2, d3, d4, d5) -> (d2)
computeSliceParameters: raw size: block with no terminator, has %25 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%7 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 4096, 1568)>}> : (index) -> index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: new size: block with no terminator, has %25 = "affine.apply"(%7) <{map = affine_map<(d0) -> (d0 - 1)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%7 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 4096, 1568)>}> : (index) -> index
ImplicitTypeIDRegistry::lookupOrInsert(mlir::tensor::detail::InsertSliceOpGenericAdaptorBase::Properties)
[transform-dialect] Top-level payload:
operation's operand is unlinked
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>, tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>, sym_name = "conv_2d_nchw_fchw"}> ({
^bb0(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>):
  "func.return"(<<UNKNOWN SSA VALUE>>) : (tensor<1x256x64x64xf32>) -> ()
}) : () -> ()
[transform-dialect] Top-level payload:
operation's operand is unlinked
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>, tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>, sym_name = "conv_2d_nchw_fchw"}> ({
^bb0(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>):
  "func.return"(<<UNKNOWN SSA VALUE>>) : (tensor<1x256x64x64xf32>) -> ()
}) : () -> ()
operation's operand is unlinked
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<1x128x66x66xf32>, tensor<256x128x3x3xf32>, tensor<1x256x64x64xf32>) -> tensor<1x256x64x64xf32>, sym_name = "conv_2d_nchw_fchw"}> ({
^bb0(%arg0: tensor<1x128x66x66xf32>, %arg1: tensor<256x128x3x3xf32>, %arg2: tensor<1x256x64x64xf32>):
  "func.return"(<<UNKNOWN SSA VALUE>>) : (tensor<1x256x64x64xf32>) -> ()
}) : () -> ()
transform-opt: /home/marcio/work/llvm-project/mlir/include/mlir/IR/UseDefLists.h:198: mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() [OperandType = mlir::OpOperand]: Assertion `use_empty() && "Cannot destroy a value that still has uses!"' failed.

Program received signal SIGABRT, Aborted.
__pthread_kill_implementation (no_tid=0, signo=6, threadid=<optimized out>) at ./nptl/pthread_kill.c:44
warning: 44     ./nptl/pthread_kill.c: No such file or directory
(gdb)
(gdb) bt
#0  __pthread_kill_implementation (no_tid=0, signo=6, threadid=<optimized out>) at ./nptl/pthread_kill.c:44
#1  __pthread_kill_internal (signo=6, threadid=<optimized out>) at ./nptl/pthread_kill.c:78
#2  __GI___pthread_kill (threadid=<optimized out>, signo=signo@entry=6) at ./nptl/pthread_kill.c:89
#3  0x00007ffff7a3d26e in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26
#4  0x00007ffff7a208ff in __GI_abort () at ./stdlib/abort.c:79
#5  0x00007ffff7a2081b in __assert_fail_base (fmt=0x7ffff7bc81e8 "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n",
    assertion=assertion@entry=0x55555e1a2d7e "use_empty() && \"Cannot destroy a value that still has uses!\"",
    file=file@entry=0x55555e1999b9 "/home/marcio/work/llvm-project/mlir/include/mlir/IR/UseDefLists.h", line=line@entry=198,
    function=function@entry=0x55555e1a2dbb "mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() [OperandType = mlir::OpOperand]")
    at ./assert/assert.c:94
#6  0x00007ffff7a33507 in __assert_fail (assertion=0x55555e1a2d7e "use_empty() && \"Cannot destroy a value that still has uses!\"",
    file=0x55555e1999b9 "/home/marcio/work/llvm-project/mlir/include/mlir/IR/UseDefLists.h", line=198,
    function=0x55555e1a2dbb "mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() [OperandType = mlir::OpOperand]") at ./assert/assert.c:103
#7  0x0000555555b69c18 in mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList (this=0x555562820f00)
    at /home/marcio/work/llvm-project/mlir/include/mlir/IR/UseDefLists.h:198
#8  0x0000555555b69ba5 in mlir::detail::ValueImpl::~ValueImpl (this=0x555562820f00) at /home/marcio/work/llvm-project/mlir/include/mlir/IR/Value.h:40
#9  0x0000555555b69b85 in mlir::detail::BlockArgumentImpl::~BlockArgumentImpl (this=0x555562820f00) at /home/marcio/work/llvm-project/mlir/include/mlir/IR/Value.h:293
#10 0x0000555555b684ac in mlir::BlockArgument::destroy (this=0x7fffffffd6f8) at /home/marcio/work/llvm-project/mlir/include/mlir/IR/Value.h:345
#11 0x0000555555b665a9 in mlir::Block::~Block (this=0x555562820a30) at /home/marcio/work/llvm-project/mlir/lib/IR/Block.cpp:23
#12 0x0000555555b6b6a7 in llvm::ilist_alloc_traits<mlir::Block>::deleteNode (V=0x555562820a30) at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:42
#13 0x0000555555b6b665 in llvm::iplist_impl<llvm::simple_ilist<mlir::Block>, llvm::ilist_traits<mlir::Block> >::erase (this=0x5555628761b8, where=...)
    at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:205
#14 0x0000555555cf7ffb in llvm::iplist_impl<llvm::simple_ilist<mlir::Block>, llvm::ilist_traits<mlir::Block> >::erase (this=0x5555628761b8, first=..., last=...)
    at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:242
#15 0x0000555555cf7f1b in llvm::iplist_impl<llvm::simple_ilist<mlir::Block>, llvm::ilist_traits<mlir::Block> >::clear (this=0x5555628761b8)
    at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:246
#16 0x0000555555d194d5 in llvm::iplist_impl<llvm::simple_ilist<mlir::Block>, llvm::ilist_traits<mlir::Block> >::~iplist_impl (this=0x5555628761b8)
    at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:147
#17 0x0000555555d19025 in llvm::iplist<mlir::Block>::~iplist (this=0x5555628761b8) at /home/marcio/work/llvm-project/llvm/include/llvm/ADT/ilist.h:327
#18 0x0000555555d17ab2 in mlir::Region::~Region (this=0x5555628761b8) at /home/marcio/work/llvm-project/mlir/lib/IR/Region.cpp:20
#19 0x0000555555cec645 in mlir::Operation::~Operation (this=0x555562876150) at /home/marcio/work/llvm-project/mlir/lib/IR/Operation.cpp:202
#20 0x0000555555cec7ce in mlir::Operation::destroy (this=0x555562876150) at /home/marcio/work/llvm-project/mlir/lib/IR/Operation.cpp:213
#21 0x0000555555ced9ff in mlir::Operation::erase (this=0x555562876150) at /home/marcio/work/llvm-project/mlir/lib/IR/Operation.cpp:543
#22 0x0000555555af16ca in mlir::OwningOpRef<mlir::Operation*>::~OwningOpRef (this=0x7fffffffdd88)
    at /home/marcio/work/llvm-project/mlir/include/mlir/IR/OwningOpRef.h:39
#23 0x0000555555a827a3 in processPayloadBuffer (os=..., inputBuffer=std::unique_ptr<llvm::MemoryBuffer> = {...},
    transformBuffer=std::unique_ptr<llvm::MemoryBuffer> = {...}, transformLibraries=..., registry=...)
    at /home/marcio/work/SConvTransform/transform-opt/transform-opt.cpp:311
#24 0x0000555555a81f95 in runMain (argc=4, argv=0x7fffffffe2d8) at /home/marcio/work/SConvTransform/transform-opt/transform-opt.cpp:397
#25 0x0000555555a819b2 in main (argc=4, argv=0x7fffffffe2d8) at /home/marcio/work/SConvTransform/transform-opt/transform-opt.cpp:403
(gdb)
